[{"content":"Introduction Recently, I was building my portfolio site using React and the built-in create-react-app toolchain. The webpage worked well and I was able to deploy it on GitHub Pages with ease. However, create-react-app uses client-side rendering, which causes an obvious layout shift of the components when the page is first loaded or refreshed. Not a big deal, but it\u0026rsquo;s annoyingüò†.\nSince the webpage doesn\u0026rsquo;t change often, the best solution is to utilize static site generation (SSG), which pre-renders the page and thus eliminate the layout shift. Unfortunately, create-react-app doesn\u0026rsquo;t provide the functionality out of the box, and although there are some third-party packages such as react-snap that do the job, they are outdated and don\u0026rsquo;t support the latest React versions.\nTherefore, I decided to migrate to Next.js, a popular React framework for building web applications with server-side rendering and static site generation functionalities. The migration process is quite simple, and in this post I will guide you through how I did it, using my own site as example. See resources for the complete code.\nGetting Started First, uninstall react-scripts and install Next.js:\n1 2 npm uninstall react-scripts npm install next Then, replace the scripts in package.json from react-scripts:\n1 2 3 4 5 6 7 // package.json { ‚ùå \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;react-scripts start\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;react-scripts build\u0026#34; } } to Next.js:\n1 2 3 4 5 6 7 8 9 // package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;next start\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;next build\u0026#34;, \u0026#34;export\u0026#34;: \u0026#34;next export\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;next dev\u0026#34; } } Then, create a folder named pages in the root directory, and add a file named _document.js with the following content:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* pages/_document.js */ import { Html, Head, Main, NextScript } from \u0026#34;next/document\u0026#34;; export default function Document() { return ( \u0026lt;Html\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico?\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Chin Hang\u0026#39;s Portfolio\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; href=\u0026#34;/logo192.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;/manifest.json\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;Main /\u0026gt; \u0026lt;NextScript /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/Html\u0026gt; ); } The content in \u0026lt;Head\u0026gt; was copied from that of \u0026lt;head\u0026gt; in public/index.html. Note that we remove the %PUBLIC_URL% from the href:\n1 2 \u0026lt;!-- public/index.html --\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;%PUBLIC_URL%/favicon.ico?\u0026#34; /\u0026gt; to:\n1 2 /* pages/_document.js */ \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico?\u0026#34; /\u0026gt; In short, this document is where we add the \u0026lt;head\u0026gt; code that are common to all pages, which Next.js will later pick up for page rendering. Also note that some other metadata such as title, viewport, and charSet are not placed here but rather in pages/_app.js, which will be created later. The \u0026lt;Main /\u0026gt; and \u0026lt;NextScript /\u0026gt; components are needed by Next.js and are not of our concern.\nInside the same pages folder, create another file named _app.js with the following content:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* pages/_app.js */ import Head from \u0026#34;next/head\u0026#34;; export default function MyApp({ Component, pageProps }) { return ( \u0026lt;\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;meta charSet=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Chin Hang\u0026#39;s Portfolio\u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;Component {...pageProps} /\u0026gt; \u0026lt;/\u0026gt; ); } In short, this document is the starting point where all the pages are initialized, and thus is useful for making changes that are common to all pages such as adding global css. Here, we put the rest of the metadata such as viewport and title as recommended by Next.js. I put the \u0026lt;title\u0026gt; here because my site is a single-page application and thus all pages share the same title.\nWe can now delete public/index.html since it\u0026rsquo;s not used anymore.\nRename the src folder to components, which is the convention used in Next.js.\nThen, we create another file named index.js inside the pages folder with the following content:\n1 2 3 4 5 6 /* pages/index.js */ import App from \u0026#34;../components/App\u0026#34;; export default function HomePage() { return (\u0026lt;App /\u0026gt;) } This file is the entry point to our home page, so I return my App here, which contains my home page elements. The content in this file should be similar to what the original src/index.js was doing, so if you have made any changes to it you should probably adapt it here.\nWe can now delete components/index.js (previously src/index.js) since it\u0026rsquo;s not used anymore.\nAdd the out and .next folders used by Next.js for output to .gitignore (if exists):\n1 2 3 4 5 6 7 # .gitignore ... /out .next ... Now, we can run our application and it should work the same as before:\n1 npm run dev If you want to generate the static assets for deployment, run:\n1 2 npm run build npm run export and the generated files will be placed in out/ folder.\nThat\u0026rsquo;s it! We have successfully migrated to Next.jsüéâ. Now it\u0026rsquo;s time to deploy our static site to production, which is GitHub Pages in our case.\nDeploy to GitHub Pages To streamline the deployment process, we make use of GitHub Action to generate the static assets and deploy it to GitHub Pages whenever the code is pushed to main. Create a file .github/workflows/gh-pages.yml with the following content:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # .github/workflows/gh-pages.yml name: GitHub Pages deploy on: push: branches: [main] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-node@v3 with: node-version: 16 - name: Installing packages run: npm ci - name: Build static pages run: npm run build \u0026amp;\u0026amp; npm run export \u0026amp;\u0026amp; touch ./out/.nojekyll - name: Deploy üöÄ uses: JamesIves/github-pages-deploy-action@v4.4.1 with: token: ${{ secrets.GITHUB_TOKEN }} folder: out # The folder the action will deploy to Note that in the \u0026ldquo;build static pages\u0026rdquo; stage, we add a .nojekyll file into the out/ folder generated by build and export. This is because next export puts some static files in out/_next, and by default GitHub Pages ignores underscore-prefixed directories. Therefore, we add a .nojekyll file in the same level as the _next directory to avoid it being ignored. Then, in the \u0026ldquo;deploy\u0026rdquo; stage, we specify out/ as our folder so that its content will be copied to the root of our gh-pages branch.\nThe last step is to change the settings of our repo to serve the content from root of gh-pages branch as follows: Also, make sure you set the Settings \u0026gt; Actions \u0026gt; General \u0026gt; Workflow permissions to \u0026ldquo;Read and write permissions\u0026rdquo; so that GitHub Action is allowed to help us deploy. Now, every time we push our code to the main branch of our repository, our website will be deployed automaticallyüëè.\nMore About the Migration The above migration steps work perfectly for my single-page portfolio site, but there could be many more configurations to do depending on how complex your site is. For example, if your site has multiple routes or has problems resolving image url in production, there may need to be more changes such as adding environment variables. Read more on the official guide if you are having issues.\nExtra: Faster Font Loading Although the layout shift due to client-side rendering is now solved with static site generation, there is still one thing that bugs me ‚Äî the font. Because I\u0026rsquo;m using Google Font, there is some delay in fetching the font from Google\u0026rsquo;s CDN, which causes the browser to use the default font before switching to my font only when it\u0026rsquo;s fully fetched. That causes a visible font/layout change to my landing page as wellüò†.\nLuckily, Next.js provides built-in support for automatic self-hosting for any font file. This means we can load web fonts much faster and minimizes the visible effect of layout shift. To do so, we just need to:\nImport the next/font package in our code, Declare the font we want, and Use it to set our font family. To demonstrate, for my site, I changed from using Material UI (MUI) fontsource:\n1 2 3 4 5 6 7 8 9 10 11 // MUI fontsource ‚ùå import \u0026#34;@fontsource/dm-sans\u0026#34;; import { ThemeProvider, createTheme } from \u0026#34;@mui/material/styles\u0026#34;; const simpleTheme = createTheme({ typography: { allVariants: { fontFamily: \u0026#34;DM Sans, sans-serif\u0026#34;, }, }, }); to next/font:\n1 2 3 4 5 6 7 8 9 10 11 12 // next/font import { DM_Sans } from \u0026#39;next/font/google\u0026#39;; import { ThemeProvider, createTheme } from \u0026#34;@mui/material/styles\u0026#34;; const dm_sans = DM_Sans({ weight: [\u0026#34;400\u0026#34;], subsets: [\u0026#39;latin\u0026#39;] }); const simpleTheme = createTheme({ typography: { allVariants: { fontFamily: dm_sans.style.fontFamily, }, }, }); By simply using the font package provided by Next.js, our font will be automatically self-hosted, which improves the load time by multiple magnitudes.\nSummary We have gone through how to migrate our React application from create-react-app to Next.js so that we could do static site generation and speed up our website. We have also learned how to deploy our static site to GitHub Pages, as well as how to utilize font package from Next.js for faster font loading. If you are facing similar problem as me, the migration is well worth it.\nResources See the code changes in effect: https://github.com/CookieHoodie/cookiehoodie.github.io/compare/8442a7e57a350b1e9981eeb29be239a600e4b6f0...417d928e1e84730475cbc387d96bb3bb2cea9985\n","permalink":"https://cookiehoodie.github.io/blog/posts/tech/react-to-nextjs/","summary":"Introduction Recently, I was building my portfolio site using React and the built-in create-react-app toolchain. The webpage worked well and I was able to deploy it on GitHub Pages with ease. However, create-react-app uses client-side rendering, which causes an obvious layout shift of the components when the page is first loaded or refreshed. Not a big deal, but it\u0026rsquo;s annoyingüò†.\nSince the webpage doesn\u0026rsquo;t change often, the best solution is to utilize static site generation (SSG), which pre-renders the page and thus eliminate the layout shift.","title":"Migrate From create-react-app to Next.js for Static Site Generation"},{"content":"Introduction Whenever we want to start working on a new project with new tools or frameworks, the first step is always to install the dependencies for local development. However, the installation process could be painful especially if different versions of existing tools are needed, forcing us to have multiple versions that eat up the storage space on our device. Not to mention, the installed tools could be located all over the place, making it hard to locate and uninstall them when they are no longer needed.\nFor those of you who have used Docker before, I think we could all agree that it is a very handy tool to manage dependencies. We just need to package everything that our application needs into the Docker image, then we could simply run our application using Docker in any environment.\nNormally, Docker is used for deployment, but today we are going to utilize its power to setup our development environment to eliminate the need to install any tools locally. We will use a powerful Visual Studio Code (VSCode) extension, Dev Containers, to achieve the seamless development process.\nPrerequisites Before we begin, make sure that you have the following software installed:\nDocker: https://www.docker.com/get-started. Visual Studio Code: https://code.visualstudio.com/. Dev Containers extension for VSCode: https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers. Getting Started In short, Dev Containers mounts our project folder into a Docker container, so we could then run our project using the dependencies that reside in the container.\nTherefore, a typical development workflow looks like this:\nWrite a Dockerfile that contains all dependencies needed to run our application. Run Dev Containers, which will create a Docker container using the Dockerfile we created and mount our project folder into it. Modify our source code on VSCode and run our application on VSCode terminal which is connected to the container. To demonstrate, we will use this workflow to develop and run a Node.js web application. The final code could be found in Resources at the end of the blog.\nSetting up VSCode with Dev Containers First, create a new folder for the project. Launch VSCode and click File \u0026gt; Open Folder to open the folder just created. ‚ö†Ô∏èIf your Docker is installed in Windows WSL, you need to download the WSL extentsion. Then, open the Command Palette in VSCode by pressing Ctrl+Shift+P, and type and choose \u0026ldquo;WSL: Open Folder in WSL\u0026rdquo; instead. Create a Dockerfile in the project folder with the following content: 1 FROM node:18-alpine This creates an environment with Node.js runtime and change our starting directory to /app. Open the Command Palette in VSCode by pressing Ctrl+Shift+P (Windows, Linux) or Command+Shift+P (Mac). Type and choose \u0026ldquo;Dev Containers: Add Dev Container Configuration Files.\u0026rdquo; In the next prompt, choose \u0026ldquo;From Dockerfile.\u0026rdquo; Then in the Select Features prompt, press \u0026ldquo;OK\u0026rdquo; without selecting any additional feature. A devcontainer.json will then be created under the .devcontainer folder. build.context sets the path that the Docker build should be run from relative to devcontainer.json, which in this case is where our Dockerfile is located. build.dockerfile points to the location of a Dockerfile that defines the contents of the container, which we defined. Open the Command Palette again and choose \u0026ldquo;Dev Containers: Rebuild and Reopen in Container\u0026rdquo; The workspace will be reopened in the container, and if we press Ctrl+` to bring up the integrated terminal, we can see that we are inside the container environment! By default, Dev Containers mounts our project folder to /workspaces/{project_name} in the container. Thus, any file we create inside the virtual environment will also be reflected in our local folder.\nBuilding our Application In the terminal, run: 1 npm init and keep pressing Enter until the end of the prompt. Install Express framework: 1 npm install express Create a file named index.js with the following content: 1 2 3 4 5 6 7 8 9 10 11 const express = require(\u0026#39;express\u0026#39;) const app = express() const port = 3000 app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(\u0026#39;Hello World!\u0026#39;) }) app.listen(port, () =\u0026gt; { console.log(`Example app listening on port ${port}`) }) Start the server: 1 node index.js Open a local browser and visit http://localhost:3000 to see the running server. Note that VSCode automatically helps us map local port 3000 to that of the container, so we don\u0026rsquo;t need to configure it explicitly. And there we go! We have successfully developed and run a Node.js application without having to installed the tools locally.\nFinishing Off To make the tutorial complete, we should also package our application properly for deployment/distribution later. Update the Dockerfile with the following content:\n1 2 3 4 5 6 7 8 9 10 FROM node:18-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . EXPOSE 3000 CMD [\u0026#34;node\u0026#34;, \u0026#34;index.js\u0026#34;] Then, in a local terminal, we could then run our program using the following commands:\n1 2 3 4 # Inside the project directory docker build -t dev-container . # Make sure the previous application in VSCode is stopped before running this docker run --rm -p 3000:3000 dev-container Now, our application is ready to be shipped.\nSome Notes We use the same Dockerfile for both development and deployment, but you could choose to use different files to avoid confusion. However, that comes with the cost of potential descrepency between development and deployment. There are a lot more configurations that you could do with the container environment through devcontainer.json according to your needs. Read the official documentation to learn more. If we create files through a dev container, there could be some permission issues when accessing them locally. Git commands might encounter permissions issues as well. To resolve them, we may have to manually change the files permission or go through the pain of setting up a non-root user. Summary We have demonstrated how to use Dev Containers and VSCode to develop and package a web application. It is a very powerful tool that helps us manage dependencies which we otherwise have to manage on our local machine ourselves. If you are a big fan of minimizing local tools installation like me, you should definitely check this out.\nResources Code for this tutorial: https://github.com/CookieHoodie/tutorials/tree/main/dev_containers ","permalink":"https://cookiehoodie.github.io/blog/posts/tech/docker-vscode-development/","summary":"Introduction Whenever we want to start working on a new project with new tools or frameworks, the first step is always to install the dependencies for local development. However, the installation process could be painful especially if different versions of existing tools are needed, forcing us to have multiple versions that eat up the storage space on our device. Not to mention, the installed tools could be located all over the place, making it hard to locate and uninstall them when they are no longer needed.","title":"Using Docker with VSCode for Local Development"}]